use rayon::prelude::*;
use sha2::{Sha256, Sha512, Digest};
use data_encoding::HEXLOWER;
use std::convert::TryInto;
use std::hint::unreachable_unchecked;
use std::io;
use std::fs::File;
use std::io::BufRead;

const HEXTABLE: [u8; 16] = [b'0',b'1',b'2',b'3',b'4',b'5',b'6',b'7', b'8', b'9',b'a',b'b',b'c',b'd',b'e',b'f'];

// convert and copy bytes to hex
// this is faster that encoding for some reson!
#[inline]
fn hex_cpy(input: &[u8; 32], output: &mut [u8; 64]) {
    unsafe {
        for i in 0..32 {
            let bin = input.get_unchecked(i);
            let out1 = output.get_unchecked_mut(i*2);
            *out1 = HEXTABLE[(bin/16) as usize];
            drop(out1);
            let out2 = output.get_unchecked_mut(i*2 + 1);
            *out2 = HEXTABLE[(bin%16) as usize];
        }
    }
}

#[inline]
// concatinate and hash w/ SHA256
fn hashab(a: &[u8],b: &[u8], outbuf: &mut [u8; 32]) {
    let mut context = Sha256::new();
    context.update(a);
    context.update(b);
    let s = context.finalize();
    unsafe {
        for i in (0..32) {
            *outbuf.get_unchecked_mut(i) = *s.get_unchecked(i);
        }
    }
     
}

#[inline]
// hash a password with a salt -> outbuf, with the darrows algorithm
//
// Theh hash is SHA256(HEX(SHA256($pass:HEX(SHA256($pass:$salt))))
//
fn genhash(pass: &[u8], salt: &[u8], outbuf: &mut [u8; 32]) {
    let mut result_hash_0 = [0; 32];
    hashab(pass,salt,&mut result_hash_0);
    let mut result_hash_0_hex = [0; 32*2];    
    // we have to convert the hash to hex becuse of @ZeroTix's bad code
    hex_cpy(&result_hash_0, &mut result_hash_0_hex);
    
    let mut result_hash_1 = [0; 32];
    hashab(pass,&result_hash_0_hex,&mut result_hash_1);
    let mut result_hash_1_hex = [0; 32*2];
    hex_cpy(&result_hash_1, &mut result_hash_1_hex);
    
    let mut result_hash_2 = [0; 32];
    hashab(&[],&result_hash_1_hex,outbuf);
}

#[test]
fn test_ab() {
    // the sha256 hash of "passwd" in hex
    let testab_hash = b"0d6be69b264717f2dd33652e212b173104b4a647b7c11ae72e9885f11cd312fb";
    let testab_a = b"pass";
    let testab_b = b"wd";
    
    // buffer for binay form of hash
    let mut testab_raw_hash = [0; 32];
    HEXLOWER.decode_mut(testab_hash,&mut testab_raw_hash).unwrap();
    
    let mut result_hash = [0; 32];
    hashab(testab_a,testab_b,&mut result_hash);

    // the computed hash must match sample hash
    assert_eq!(result_hash,testab_raw_hash);
}

#[test]
fn test_genhash() {
    // the hash generated by darrows when "passwd" is sent in chat
    let test_hash = b"5447b9c4482c90e26c4f132bcbaa180459a345049a89de82ab880eb582c7ff2b";
    let test_pass = b"passwd";
    // the current salt for darrows
    let test_salt = b"fc8877c24d85d246e3234f2dcca3a33a842c32f81b6a8f7f60696da988a1fea4";
    let mut test_raw_hash = [0; 32];
    HEXLOWER.decode_mut(test_hash,&mut test_raw_hash).unwrap();
    
    let mut result_hash = [0; 32];

    genhash(test_pass,test_salt,&mut result_hash);
    
    assert_eq!(result_hash,test_raw_hash);
}

fn main() {
    // real hash for dev!!!
    let hash_tgt = b"aaf450a516f3ba08fceaa80687bb5c0147a515a634464517026cfcae3adea8a9";
    
    // TEST HASH ("pass12")    
    //let hash_tgt = b"0e67594567b12b5dff7924a39e44e2defebc9d53600d9ad34e2dcadc814a47d7";

    // the salt is concationated as hex
    let hash_salt = b"fc8877c24d85d246e3234f2dcca3a33a842c32f81b6a8f7f60696da988a1fea4";

    // decode hash to binary
    let mut tgt_raw_hash = [0; 32];
    HEXLOWER.decode_mut(hash_tgt,&mut tgt_raw_hash).unwrap();
    // shadow hash_tgt
    let hash_tgt = tgt_raw_hash;

    println!("begining cracking");

    let mut counter = 0_usize;
    
    loop {
        // get 1000 password candidates from stdin
    	let candidates: Vec<String>  = io::stdin().lock().lines().take(1000).map(|x| x.unwrap()).collect();

        counter = counter + candidates.len();
    	   
        candidates
            .iter()
            .par_bridge()
            .for_each(|candidate| {
                let mut result_hash = [0; 32];
                genhash(candidate.as_bytes(),hash_salt,&mut result_hash);
                if (result_hash == hash_tgt) {
                    println!("DEVKEY {}: {}",counter,candidate)
                }
            })
    }
}
